# Default values for kairoscloud-chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# Global chart configuration
nameOverride: ""
fullnameOverride: ""

# ServiceAccount configuration
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# Deployment configuration
deployment:
  enabled: true
  replicaCount: 1
  
  image:
    repository: nginx
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: ""
  
  imagePullSecrets: []
  
  podAnnotations: {}
  
  podSecurityContext:
    fsGroup: 2000
  
  securityContext:
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1000
  
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 256Mi
  
  nodeSelector: {}
  
  tolerations: []
  
  affinity: {}
  
  # Additional environment variables
  env: []
    # - name: ENV_VAR_NAME
    #   value: "value"
  
  # Additional volumes
  extraVolumes: []
    # - name: extra-volume
    #   configMap:
    #     name: extra-config
  
  # Additional volume mounts
  extraVolumeMounts: []
    # - name: extra-volume
    #   mountPath: /extra/path
  
  # Liveness and readiness probes
  livenessProbe:
    enabled: true
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  
  readinessProbe:
    enabled: true
    httpGet:
      path: /ready
      port: http
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
  
  # Startup probe
  startupProbe:
    enabled: false
    httpGet:
      path: /startup
      port: http
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 1
    failureThreshold: 30

# Service configuration
service:
  type: ClusterIP
  port: 80
  targetPort: 8080
  annotations: {}

# Ingress configuration
ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: Prefix
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# Autoscaling configuration
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# StatefulSet specific configuration
statefulset:
  enabled: false
  serviceName: ""
  podManagementPolicy: OrderedReady
  updateStrategy:
    type: RollingUpdate
  
  # Pod configuration (similar to deployment)
  replicaCount: 1
  
  image:
    repository: nginx
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: ""
  
  imagePullSecrets: []
  
  podAnnotations: {}
  
  podSecurityContext:
    fsGroup: 2000
  
  securityContext:
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1000
  
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 256Mi
  
  nodeSelector: {}
  
  tolerations: []
  
  affinity: {}
  
  # Additional environment variables
  env: []
    # - name: ENV_VAR_NAME
    #   value: "value"
  
  # Additional volumes
  extraVolumes: []
    # - name: extra-volume
    #   configMap:
    #     name: extra-config
  
  # Additional volume mounts
  extraVolumeMounts: []
    # - name: extra-volume
    #   mountPath: /extra/path
  
  # Liveness and readiness probes
  livenessProbe:
    enabled: true
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  
  readinessProbe:
    enabled: true
    httpGet:
      path: /ready
      port: http
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
  
  # Startup probe
  startupProbe:
    enabled: false
    httpGet:
      path: /startup
      port: http
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 1
    failureThreshold: 30

# DaemonSet specific configuration
daemonset:
  enabled: false
  updateStrategy:
    type: RollingUpdate
  
  # Pod configuration (similar to deployment and statefulset)
  image:
    repository: nginx
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: ""
  
  imagePullSecrets: []
  
  podAnnotations: {}
  
  podSecurityContext:
    fsGroup: 2000
  
  securityContext:
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1000
  
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 256Mi
  
  nodeSelector: {}
  
  tolerations: []
  
  affinity: {}
  
  # Additional environment variables
  env: []
    # - name: ENV_VAR_NAME
    #   value: "value"
  
  # Additional volumes
  extraVolumes: []
    # - name: extra-volume
    #   configMap:
    #     name: extra-config
  
  # Additional volume mounts
  extraVolumeMounts: []
    # - name: extra-volume
    #   mountPath: /extra/path
  
  # Init containers
  initContainers: []
    # - name: init-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "Init container running"']
  
  # Liveness and readiness probes
  livenessProbe:
    enabled: true
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  
  readinessProbe:
    enabled: true
    httpGet:
      path: /ready
      port: http
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
  
  # Startup probe
  startupProbe:
    enabled: false
    httpGet:
      path: /startup
      port: http
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 1
    failureThreshold: 30

# PersistentVolumeClaim configuration
persistence:
  enabled: false
  storageClass: ""
  accessMode: ReadWriteOnce
  size: 8Gi
  annotations: {}

# ConfigMap configuration
configMap:
  enabled: true
  data: {}
    # key1: value1
    # key2: value2

# PodDisruptionBudget configuration
podDisruptionBudget:
  enabled: false
  minAvailable: 1
  # maxUnavailable: 1

# NetworkPolicy configuration
networkPolicy:
  enabled: false
  ingress:
    enabled: true
    namespaceSelector: {}
    podSelector: {}
    ipBlocks: []
    ports:
      - protocol: TCP
        port: 80
  egress:
    enabled: true
    namespaceSelector: {}
    podSelector: {}
    ipBlocks: []
    ports:
      - protocol: TCP
        port: 53
      - protocol: UDP
        port: 53

# Secret configuration
secret:
  enabled: false
  type: Opaque
  annotations: {}
  data: {}
    # key1: value1
    # key2: value2
  stringData: {}
    # key1: value1
    # key2: value2

# RBAC configuration
rbac:
  enabled: false
  rules: []
    # - apiGroups: [""]
    #   resources: ["pods"]
    #   verbs: ["get", "list", "watch"]
  clusterRole:
    enabled: false
    rules: []
      # - apiGroups: [""]
      #   resources: ["nodes"]
      #   verbs: ["get", "list", "watch"]

# ServiceMonitor configuration (Prometheus)
serviceMonitor:
  enabled: false
  labels: {}
  annotations: {}
  port: http
  path: /metrics
  interval: 30s
  scrapeTimeout: 10s
  scheme: http
  tlsConfig: {}
  bearerTokenSecret: {}
  basicAuth: {}
  namespaceSelector: {}
  sampleLimit: 0

# Certificate configuration (cert-manager)
certificate:
  enabled: false
  annotations: {}
  issuerRef:
    name: ""
    kind: Issuer
    group: cert-manager.io
  dnsNames: []
    # - example.com
    # - www.example.com
  commonName: ""
  duration: ""
  renewBefore: ""
  usages: []
  keyAlgorithm: RSA
  keySize: 2048

# VolumeSnapshot configuration
volumeSnapshot:
  enabled: false
  annotations: {}
  source:
    persistentVolumeClaimName: ""
    volumeSnapshotContentName: ""
  volumeSnapshotClassName: ""

# CronJob configuration
cronJob:
  enabled: false
  annotations: {}
  schedule: "0 0 * * *"  # Daily at midnight
  timeZone: ""
  concurrencyPolicy: Allow
  failedJobsHistoryLimit: 1
  successfulJobsHistoryLimit: 3
  suspend: false
  activeDeadlineSeconds: 0
  backoffLimit: 6
  ttlSecondsAfterFinished: 0
  restartPolicy: OnFailure
  image:
    repository: nginx
    tag: ""
    pullPolicy: IfNotPresent
  imagePullSecrets: []
  command: []
  args: []
  env: []
  resources: {}
  volumeMounts: []
  volumes: []
  nodeSelector: {}
  affinity: {}
  tolerations: []
  securityContext: {}

# LimitRange configuration
limitRange:
  enabled: false
  annotations: {}
  limits: []
    # - type: Container
    #   max:
    #     cpu: 2
    #     memory: 4Gi
    #   min:
    #     cpu: 100m
    #     memory: 128Mi
    #   default:
    #     cpu: 500m
    #     memory: 512Mi
    #   defaultRequest:
    #     cpu: 250m
    #     memory: 256Mi

# ResourceQuota configuration
resourceQuota:
  enabled: false
  annotations: {}
  hard: {}
    # requests.cpu: "2"
    # requests.memory: 4Gi
    # limits.cpu: "4"
    # limits.memory: 8Gi
    # pods: "10"
    # services: "5"
    # persistentvolumeclaims: "4"
  scopeSelector: {}
  scopes: []

# Job configuration
job:
  enabled: false
  annotations: {}
  activeDeadlineSeconds: 0
  backoffLimit: 6
  completions: 1
  parallelism: 1
  ttlSecondsAfterFinished: 0
  restartPolicy: Never
  image:
    repository: nginx
    tag: ""
    pullPolicy: IfNotPresent
  imagePullSecrets: []
  command: []
  args: []
  env: []
  resources: {}
  volumeMounts: []
  volumes: []
  nodeSelector: {}
  affinity: {}
  tolerations: []
  securityContext: {}

# MutatingWebhookConfiguration for admission control
mutatingWebhookConfiguration:
  enabled: false
  annotations: {}
  webhooks: []
    # - name: example-mutating-webhook
    #   clientConfig:
    #     service:
    #       name: webhook-service
    #       namespace: default
    #       path: /mutate
    #       port: 443
    #     caBundle: ""  # Base64-encoded CA certificate
    #   rules:
    #     - operations: ["CREATE", "UPDATE"]
    #       apiGroups: [""]
    #       apiVersions: ["v1"]
    #       resources: ["pods"]
    #       scope: "Namespaced"
    #   failurePolicy: Fail
    #   matchPolicy: Equivalent
    #   namespaceSelector: {}
    #   objectSelector: {}
    #   sideEffects: None
    #   timeoutSeconds: 10
    #   admissionReviewVersions: ["v1"]
    #   reinvocationPolicy: IfNeeded

# ValidatingWebhookConfiguration for admission control
validatingWebhookConfiguration:
  enabled: false
  annotations: {}
  webhooks: []
    # - name: example-validating-webhook
    #   clientConfig:
    #     service:
    #       name: webhook-service
    #       namespace: default
    #       path: /validate
    #       port: 443
    #     caBundle: ""  # Base64-encoded CA certificate
    #   rules:
    #     - operations: ["CREATE", "UPDATE"]
    #       apiGroups: [""]
    #       apiVersions: ["v1"]
    #       resources: ["pods"]
    #       scope: "Namespaced"
    #   failurePolicy: Fail
    #   matchPolicy: Equivalent
    #   namespaceSelector: {}
    #   objectSelector: {}
    #   sideEffects: None
    #   timeoutSeconds: 10
    #   admissionReviewVersions: ["v1"]

# Istio Service Mesh configuration
istio:
  enabled: false
  
  # VirtualService configuration for traffic management
  virtualService:
    enabled: false
    annotations: {}
    hosts: []
      # - kairoscloud.example.com
    gateways: []
      # - kairoscloud-gateway
    http: []
      # - match:
      #   - uri:
      #       prefix: /api
      #   route:
      #   - destination:
      #       host: kairoscloud-chart
      #       port:
      #         number: 80
    tcp: []
    tls: []
    
  # AuthorizationPolicy configuration for access control
  authorizationPolicy:
    enabled: false
    annotations: {}
    action: ALLOW
    selector: {}
    rules: []
      # - from:
      #   - source:
      #       principals: ["cluster.local/ns/default/sa/sleep"]
      #   to:
      #   - operation:
      #       methods: ["GET"]
    
  # PeerAuthentication configuration for mTLS
  peerAuthentication:
    enabled: false
    annotations: {}
    selector: {}
    mtls:
      mode: STRICT
    portLevelMtls: {}
      # 8080:
      #   mode: DISABLE
    
  # RequestAuthentication configuration for JWT authentication
  requestAuthentication:
    enabled: false
    annotations: {}
    selector: {}
    jwtRules: []
      # - issuer: "https://example.com"
      #   jwksUri: "https://example.com/.well-known/jwks.json"
      #   audiences: ["api"]
    
  # Gateway configuration for ingress/egress
  gateway:
    enabled: false
    annotations: {}
    selector: {}
      # istio: ingressgateway
    servers: []
      # - port:
      #     number: 80
      #     name: http
      #     protocol: HTTP
      #   hosts:
      #   - kairoscloud.example.com
    
  # Telemetry configuration for observability
  telemetry:
    enabled: false
    annotations: {}
    selector: {}
    metrics: []
      # - providers:
      #   - name: prometheus
    accessLogging: []
      # - providers:
      #   - name: otel
    tracing: {}
      # providers:
      # - name: jaeger

# KEDA (Kubernetes Event-Driven Autoscaling) configuration
keda:
  enabled: false
  annotations: {}
  # Minimum number of replicas (defaults to autoscaling.minReplicas if not set)
  minReplicas: null
  # Maximum number of replicas (defaults to autoscaling.maxReplicas if not set)
  maxReplicas: null
  # Polling interval for metrics (e.g., "30s", "1m")
  pollingInterval: null
  # Cooldown period for scaling down (e.g., "300s", "5m")
  cooldownPeriod: null
  # Number of replicas to maintain when idle (defaults to 0)
  idleReplicaCount: null
  # Advanced KEDA configuration
  advanced: {}
    # horizontalPodAutoscalerConfig:
    #   behavior:
    #     scaleDown:
    #       stabilizationWindowSeconds: 300
    #       policies:
    #       - type: Percent
    #         value: 50
    #         periodSeconds: 60
    #     scaleUp:
    #       stabilizationWindowSeconds: 0
    #       policies:
    #       - type: Percent
    #         value: 100
    #         periodSeconds: 15
  # KEDA triggers configuration
  triggers: []
    # Example CPU trigger:
    # - type: cpu
    #   metadata:
    #     type: Utilization
    #     value: "70"
    #   metricType: Utilization
    # 
    # Example memory trigger:
    # - type: memory
    #   metadata:
    #     type: Utilization
    #     value: "80"
    #   metricType: Utilization
    #
    # Example Prometheus trigger:
    # - type: prometheus
    #   metadata:
    #     serverAddress: http://prometheus-server.monitoring.svc.cluster.local:80
    #     metricName: http_requests_per_second
    #     threshold: '100'
    #     query: sum(rate(http_requests_total[2m]))
    #   metricType: AverageValue
    #
    # Example Kafka trigger:
    # - type: kafka
    #   metadata:
    #     bootstrapServers: kafka-server:9092
    #     consumerGroup: my-group
    #     topic: my-topic
    #     lagThreshold: '5'
    #   authenticationRef:
    #     name: kafka-auth
    #     kind: Secret
    #
    # Example Redis trigger:
    # - type: redis
    #   metadata:
    #     address: redis-server:6379
    #     listName: mylist
    #     listLength: '5'
    #   authenticationRef:
    #     name: redis-auth
    #     kind: Secret
    #
    # Example HTTP trigger:
    # - type: http
    #   metadata:
    #     url: http://api.example.com/metrics
    #     valueLocation: 'body'
    #     targetValue: '100'
    #   authenticationRef:
    #     name: http-auth
    #     kind: Secret
  # Global fallback configuration
  fallback: {}
    # failureThreshold: 3
    # replicas: 1

# Chaos Mesh configuration for chaos engineering
# When enabled, automatically installs Chaos Mesh as a dependency
# and provides templates for various chaos experiments
chaosMesh:
  enabled: false
  
  # Chaos Mesh dependency configuration
  # These values are passed to the Chaos Mesh subchart
  # See: https://charts.chaos-mesh.org for full configuration options
  chaos-mesh:
    # Chaos Mesh controller configuration
    controllerManager:
      replicas: 1
      # Enable webhook for admission control
      webhook:
        enabled: true
    # Chaos Mesh daemon configuration  
    chaosDaemon:
      enabled: true
    # Chaos Mesh dashboard configuration
    dashboard:
      enabled: true
      # Enable ingress for dashboard access
      ingress:
        enabled: false
    # Chaos Mesh DNS server configuration
    dnsServer:
      enabled: true
    # Chaos Mesh chaosfs configuration
    chaosfs:
      enabled: true

  # Example chaos experiments configuration
  # These are example configurations for different chaos types
  # Uncomment and modify as needed for your specific use cases
  
  # HTTPChaos example - HTTP request chaos
  # httpChaos:
  #   enabled: true
  #   mode: "one"
  #   duration: "30s"
  #   action: "delay"
  #   delay: "10s"
  #   target: "Request"
  #   method: "GET"
  #   path: "/api"
  #   selector:
  #     namespaces:
  #       - default
  #     labelSelectors:
  #       app: my-app

  # PodChaos example - Pod failure chaos
  # podChaos:
  #   enabled: true
  #   mode: "one"
  #   duration: "60s"
  #   action: "pod-failure"
  #   selector:
  #     namespaces:
  #       - default
  #     labelSelectors:
  #       app: my-app

  # NetworkChaos example - Network delay chaos
  # networkChaos:
  #   enabled: true
  #   mode: "one"
  #   duration: "30s"
  #   action: "delay"
  #   delay:
  #     latency: "10ms"
  #     correlation: "100"
  #     jitter: "0ms"
  #   selector:
  #     namespaces:
  #       - default
  #     labelSelectors:
  #       app: my-app

  # StressChaos example - CPU stress chaos
  # stressChaos:
  #   enabled: true
  #   mode: "one"
  #   duration: "60s"
  #   stressors:
  #     cpu:
  #       workers: 1
  #       load: 50
  #   selector:
  #     namespaces:
  #       - default
  #     labelSelectors:
  #       app: my-app

  # Chaos Mesh Workflow configuration
  # Orchestrate multiple chaos experiments in serial or parallel
  # See: https://chaos-mesh.org/docs/create-chaos-mesh-workflow/
  workflow:
    enabled: false
    annotations: {}
    # Entry point of the workflow
    entry: "entry"
    # Workflow templates - each template represents a step in the workflow
    templates: []
      # Example: Parallel workflow with multiple chaos types
      # - name: "entry"
      #   type: "Parallel"
      #   deadline: "240s"
      #   children:
      #     - "stress-chaos"
      #     - "network-chaos"
      #     - "pod-chaos"
      # 
      # - name: "stress-chaos"
      #   type: "StressChaos"
      #   deadline: "60s"
      #   stressChaos:
      #     mode: "one"
      #     selector:
      #       labelSelectors:
      #         app: my-app
      #     stressors:
      #       cpu:
      #         workers: 1
      #         load: 50
      # 
      # - name: "network-chaos"
      #   type: "NetworkChaos"
      #   deadline: "30s"
      #   networkChaos:
      #     action: "delay"
      #     mode: "one"
      #     selector:
      #       labelSelectors:
      #         app: my-app
      #     delay:
      #       latency: "10ms"
      #       correlation: "100"
      #       jitter: "0ms"
      # 
      # - name: "pod-chaos"
      #   type: "PodChaos"
      #   deadline: "60s"
      #   podChaos:
      #     action: "pod-failure"
      #     mode: "one"
      #     selector:
      #       labelSelectors:
      #         app: my-app
      # 
      # Example: Serial workflow with conditional branches
      # - name: "entry"
      #   type: "Serial"
      #   deadline: "300s"
      #   children:
      #     - "health-check"
      #     - "conditional-chaos"
      # 
      # - name: "health-check"
      #   type: "Task"
      #   deadline: "30s"
      #   task:
      #     container:
      #       name: "health-check"
      #       image: "curlimages/curl:latest"
      #       command: ["curl", "-f", "http://my-app:8080/health"]
      #   conditionalBranches:
      #     - target: "pod-chaos"
      #       expression: "exitCode == 0"
      #     - target: "skip-chaos"
      #       expression: "exitCode != 0"
      # 
      # - name: "conditional-chaos"
      #   type: "PodChaos"
      #   deadline: "60s"
      #   podChaos:
      #     action: "pod-kill"
      #     mode: "one"
      #     selector:
      #       labelSelectors:
      #         app: my-app
      # 
      # - name: "skip-chaos"
      #   type: "Suspend"
      #   deadline: "10s"
      # 
      # Example: Scheduled chaos experiments
      # - name: "entry"
      #   type: "Schedule"
      #   deadline: "120s"
      #   schedule:
      #     schedule: "@every 30s"
      #     type: "PodChaos"
      #     podChaos:
      #       action: "pod-kill"
      #       mode: "one"
      #       selector:
      #         labelSelectors:
      #           app: my-app
      # 
      # Example: Status check with abort
      # - name: "entry"
      #   type: "StatusCheck"
      #   deadline: "60s"
      #   abortWithStatusCheck: true
      #   statusCheck:
      #     mode: "one"
      #     selector:
      #       labelSelectors:
      #         app: my-app
      #     type: "HTTP"
      #     http:
      #       url: "http://my-app:8080/health"
      #       method: "GET"
      #       expectedStatus: 200
